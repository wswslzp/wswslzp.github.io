<hr>
<p>title: Spinal Flow协议<br>date: 2022-03-04 16:58:24<br>tags:<br>    - SpinalHDL<br>    - ASIC<br>    - FPGA<br>categories:<br>    - SpinalHDL 硬件设计</p>
<hr>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>用于Non-blocking传输的协议，由valid标志表示当前payload的有效性。相比于存在握手规则约束的Stream，其使用更加简单，更加方便，因此相关的方法也更少，更简单。</p>
<h2 id="Stream转换"><a href="#Stream转换" class="headerlink" title="Stream转换"></a>Stream转换</h2><p>将Flow转换为Stream的函数</p>
<ul>
<li><code>toStream(overflow: Bool, fifoSize: Int, overflowOccupancyAt: Int): Stream[T]</code> ，返回一个Stream，并给一个输出信号overflow。在转换到Stream后，接一个FIFO，在超过一定深度后给assert overflow。</li>
<li><code>toStream(overflow: Bool): Stream[T]</code> ，类似上面，但没有接一个overflow，只是没有接一个FIFO。如果有传一个overflow的引用进去，那么输出一个overflow，当下游不ready的时候拉高。</li>
</ul>
<p>上面的第一个函数，是在转换Stream之后才加buffer。我们可以在转换为Stream之前加buffer<br>gg</p>
<ul>
<li><code>queueWithOccupancy(size: Int): (Stream[T], UInt)</code></li>
<li><code>queueWithAvailability(size: Int): (Stream[T], UInt)</code></li>
</ul>
<h2 id="Repeater"><a href="#Repeater" class="headerlink" title="Repeater"></a>Repeater</h2><p>给valid-payload打拍</p>
<ul>
<li><code>m2sPipe(holdPayload : Boolean = false, flush : Bool = null): Flow[T]</code> ，类似于Stream的m2sPipe。 <code>stage()</code> 和 m2sPipe() 一样。</li>
</ul>
<h2 id="负载控制"><a href="#负载控制" class="headerlink" title="负载控制"></a>负载控制</h2><p>不像Stream可以控制上游的流量，这里引入condition来控制valid。</p>
<ul>
<li><code>takeWhen(cond: Bool): Flow[T]</code></li>
<li><code>throwWhen(cond: Bool): Flow[T]</code></li>
</ul>
<h2 id="负载转换"><a href="#负载转换" class="headerlink" title="负载转换"></a>负载转换</h2><p>类似于Stream，同样提供了简单的负载转换方法</p>
<ul>
<li><code>translateWith[T2 &lt;: Data](that: T2): Flow[T2]</code></li>
<li><code>translateFrom[T2 &lt;: Data](that: Flow[T2])(dataAssignment: (T, that.payload.type) =&gt; Unit): Flow[T]</code></li>
</ul>
<h2 id="CDC处理"><a href="#CDC处理" class="headerlink" title="CDC处理"></a>CDC处理</h2><p><code>ccToggle(pushClock: ClockDomain, popClock: ClockDomain) : Flow[T]</code></p>
<p>返回下游Flow，处在另一个时钟域。</p>
